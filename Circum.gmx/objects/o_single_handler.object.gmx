<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-999</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Pre-Spawn Initialization

window_set_cursor(cr_none);  // not changed in global game settings because of debug room

// init global vars
instance_create(0, 0, o_globals);

p_emitter = part_emitter_create(global.p_system);
p_type = part_type_create();

drawn_to_surface = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player and Orb Spawns NEW
randomize();

// Screen (Circular)
screen = surface_create(room_width, room_height);

// Spawn Orbs
// FIXED 
/*
spawn_orbs(true, room_width/8, -0.5, 0, get_orb_pattern(5, DEAD_ORB, DEFAULT_ORB, DEFAULT_ORB, VOID_ORB));
spawn_orbs(true, room_width/3, 0.5, 0, get_orb_pattern(10, MASTER_ORB));
*/
/*
spawn_orbs(false, room_width/3, 0, 0, get_orb_pattern(3, DEAD_ORB, DEFAULT_ORB, CAPTURED_ORB));
spawn_orbs(false, room_width/6, 0, 0, get_orb_pattern(3, VOID_ORB, DEFAULT_ORB));
*/

// Spawning Orbs NEW
// Consider spawning with three different methods (the exact one will be selected at random):
//  1. Creating fixed-orbit rings in a setup that is prebuilt by hand
//  2. Creating fixed-orbit rings in a setup that is randomly generated
//  3. Creating randomly orbs (not fixed) in a randomly generated setup
// To implement the above, first we decide on which level generation method we will be using
// Comment: Use at least 2.25 as the denominator of room_width/x; otherwise orbs get close enough to constantly collide against edge of room
var spawning_type = irandom(2);         // Gives a number between 0 ~ 2 (including 2)
switch (spawning_type) {
    case S_FIXED_PREBUILT:  // Fixed orbit rings; prebuilt setups
        // We can have another switch statement here to pick out the prebuilt setup to use OR we can make a new function for that
        // This level is actually REALLY hard
        spawn_orbs(true, room_width/7, -0.25, 0, get_orb_pattern(4, VOID_ORB));
        spawn_orbs(true, room_width/3.5, 0.5, 0, get_orb_pattern (4, DEFAULT_ORB, DEAD_ORB));
        spawn_orbs(true, room_width/2.25, -0.5, 0, get_orb_pattern (4, DEFAULT_ORB, DEAD_ORB, DEFAULT_ORB));
        break;
    case S_FIXED_RANDOM:    // Fixed orbit rings; random setup
        var orbit_lanes = 1 + irandom(S_MAX_LANES); // Find out how many lanes we are going to have; default [1,3]
        switch (orbit_lanes) {
            case 1: // One lane
                spawn_orbs(true, room_width/3, -0.5, 0, get_orb_pattern(3, DEFAULT_ORB, irandom(CAPTURED_ORB), irandom(CAPTURED_ORB), irandom(CAPTURED_ORB)));
                break;
            case 2: // Two lanes
                spawn_orbs(true, room_width/5, -0.5, 0, get_orb_pattern(3, DEFAULT_ORB, irandom(CAPTURED_ORB)));
                spawn_orbs(true, room_width/2.5, +0.5, 0, get_orb_pattern(2, DEFAULT_ORB, irandom(CAPTURED_ORB), irandom(CAPTURED_ORB), irandom(CAPTURED_ORB)));
                break;
            case 3: // Three lanes
                spawn_orbs(true, room_width/7, -0.25, 0, get_orb_pattern(2, irandom(CAPTURED_ORB), irandom(CAPTURED_ORB)));
                spawn_orbs(true, room_width/3.5, 0.5, 0, get_orb_pattern (3, irandom(CAPTURED_ORB), irandom(CAPTURED_ORB)));
                spawn_orbs(true, room_width/2.25, -0.5, 0, get_orb_pattern (4, DEFAULT_ORB, irandom(CAPTURED_ORB), irandom(CAPTURED_ORB)));
                break;
        }
        
        break;
    case S_RANDOM:          // Random spawning of orbs   
        spawn_orbs(false, room_width/3, 0, 0, get_orb_pattern(1 + irandom(S_MAX_LANES), 
                    DEFAULT_ORB, irandom(DEAD_ORB), irandom(DEAD_ORB), irandom(VOID_ORB), irandom(VOID_ORB)));
        spawn_orbs(false, room_width/2.5, 0, 0, get_orb_pattern(1, irandom(MASTER_ORB), irandom(MASTER_ORB)));
        break;
}

// Spawn Starting Orb
var start_orb = instance_create(SCREEN_RADIUS, SCREEN_RADIUS, o_orb);
start_orb.speed = 0;  // not necessary if fixed = true, but let's keep it anyway
start_orb.fixed = true;

// Get number of orbs required to win (now that all orbs have been spawned)
num_to_win = 0;
with (o_orb) {
    if (type == DEFAULT_ORB) { other.num_to_win++; }
}

// Spawn Player
plr_color = choose(c_fuchsia, c_aqua, c_lime, c_yellow);
with (instance_create(SCREEN_RADIUS, SCREEN_RADIUS, o_player)) {
    color = other.plr_color;
    action_key = vk_space;
    num_to_win =  other.num_to_win; 
}
// set captured orbs' colors based on player color
with (o_orb) {
    if (captured) {
        do {
            color = choose(c_fuchsia, c_aqua, c_lime, c_yellow);
        } until (color != other.plr_color);
    }
}

// Spawn Hidden Opponent
instance_create(0, 0, o_fake_player);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player and Orb Spawns
/*
randomize();

//available for capture
num_free = 5;
//already claimed (not counting the orb you start on)
num_owned = 1;
//claimed by opponent (must be liberated by hammer)
num_opponent = 3;
//ricochet
num_dead = 3;
//dangerous
num_void = 1;

//how many orbs circle the starting orb
num_orb = num_free + num_owned + num_opponent + num_dead + num_void;

//the orb you start on plus all the DEFAULT orbs
num_to_win = 1+num_free + num_owned + num_opponent;

edge_buffer = 512;

var x_center = SCREEN_RADIUS;
var y_center = SCREEN_RADIUS;

// Screen (Circular)
screen = surface_create(room_width, room_height);

//starting orb
var orb;
orb = instance_create(x_center, y_center, o_orb);
//orb.speed = 0;
orb.fixed = true;
// Player
player_color = c_fuchsia;
player_id = -1;
with (instance_create(orb.x, y_center, o_player)) {
    num_orb_captured = other.num_owned;
    color = other.player_color;
    action_key = vk_space;
    num_to_win = other.num_to_win;
    other.player_id = self.id;
}

// hidden opponent
opponent_color = c_aqua;
opponent_id = -1;
with (instance_create(0,0, o_player)) {
    action_key = vk_escape;
    num_to_win = other.num_orb+1;
    visible = false;
    speed = 0;
    launch_speed = 0;
    orbit_speed = 0;
    other.opponent_id = self.id;
}

// Orbs that circle the starting orb
var rad = room_width/3;
for (var dir = 0; dir &lt; 360; dir += 360/num_orb) {
    var orb_x = x_center + rad*cos(degtorad(dir));
    var orb_y = y_center - rad*sin(degtorad(dir));
    with (instance_create(orb_x, orb_y, o_orb)) {
        speed = random_range(3,7);
        direction = random(360);
    }
}

//set their capturer or type
var orb_categories;
orb_categories[0] = num_free;
orb_categories[1] = num_owned;
orb_categories[2] = num_opponent;
orb_categories[3] = num_dead;
orb_categories[4] = num_void;

//loop thru orbs that circle the starting orb
var o_index = 1;
for(var i = 0; i &lt; 5; i++){
    for(var j = 0; j &lt; orb_categories[i]; j++){
        var cur_orb = instance_find(o_orb,o_index);
        
        //set parameters based on category
        switch(i){
        //free
        case 0: break;
        //already captured
        case 1:
            with cur_orb {
                captured = true;
                capturer = other.player_id;
                color = other.player_color;
            }
            break;
        //opponent captured
        case 2:
            with cur_orb {
                captured = true;
                capturer = other.opponent_id;
                color = other.opponent_color;
            }
            break;
        case 3:
            set_orb_type(cur_orb,DEAD_ORB);
            break;
        case 4:
            set_orb_type(cur_orb,VOID_ORB);
            break;
        }
        o_index++;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// End, Restart

if (keyboard_check_pressed(vk_escape)) {
    game_end();
}

if (keyboard_check_pressed(ord("R"))) {
    game_restart();
}
/*
if (keyboard_check_pressed(ord("F"))) {
    window_set_fullscreen(!window_get_fullscreen());
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Turn visuals on or off

if (keyboard_check_pressed(ord("V"))) {
    global.tmp_visuals_on = !global.tmp_visuals_on;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Return room_speed to normal

if (room_speed &lt; 60) {
    room_speed++;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Circlular Screen

if (!drawn_to_surface) {  // this only needs to happen once
    drawn_to_surface = true;
    surface_set_target(screen);
    draw_clear_alpha(c_black, 1);  // make entire screen black
    draw_set_blend_mode(bm_subtract);
    // DRAW WITH PRIMITIVES OR VERTEX BUFFERS FOR GREATER PRECISION?!
    draw_set_circle_precision(64);
    draw_circle(room_width/2, room_height/2, room_width/2, false);
    draw_set_alpha(1);
    draw_set_blend_mode(bm_normal);
    surface_reset_target();
}

if (surface_exists(screen)) {
    draw_surface(screen, 0, 0);
}
else {
    screen = surface_create(room_width, room_height);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Ambient Background Particles

part_system_depth(global.p_system, -98);
part_type_shape(p_type, pt_shape_flare);
part_type_blend(p_type, true);
part_type_alpha2(p_type, 1, 0);
part_type_colour1(p_type, c_white); // maybe can change color depending on which player is winning
part_type_direction(p_type, 0, 360, 0, 0); // completely random direction
part_type_speed(p_type, 0, 4, 0, 0);
part_type_size(p_type, 0.2, 0.2, 0, 0);
part_type_life(p_type, 1, 120);
part_type_orientation(p_type, 0, 360, 0, 0, false);
part_type_scale(p_type, 1, 1);
part_emitter_region(global.p_system, p_emitter, 0, room_width, 0, room_height, ps_shape_ellipse, ps_distr_linear);
part_emitter_burst(global.p_system, p_emitter, p_type, random(5));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
