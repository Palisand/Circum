<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Set in o_handler.Create
color = c_white;
action_key = vk_shift;

trail_length = 30;  // in the anticipation of a longer trail under a certain condition

radius = 5;
num_orb_captured = 0;
launch_speed = 20;
direction = choose(1, -1);  // randomly begin with a clockwise or counter-clockwise rotation

orbit = 0;
orbit_speed = 0;
orbit_speed_set = 3;
orbiting = false;
current_orb = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Win

//if there isn't already a winner, check if something changed
if (global.winner &lt; 0) {

    //you got enough to win (normal way or master orb captured)
    if (num_orb_captured &gt; instance_number(o_orb) / instance_number(o_player)) {
        global.winner = self.id;
    }
    
    //you are the only player left standing (everyone else hit void orbs)
    if (instance_number(o_player) == 1) {
        global.winner = self.id;
    }
}

// If you won, consume the entire screen
if (global.winner == self.id &amp;&amp; radius &lt; room_width) {
    radius += 20;
    depth = -99;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement &amp; Capturing

edge_bounce_circle(radius);

if (orbiting) {
    current_orb.speed = lerp(current_orb.speed,0,0.1);  // the orb being orbited is stationary
    // launch (if there isn't a winner)
    if (keyboard_check_pressed(action_key) &amp;&amp; global.winner &lt; 0) {
        speed = launch_speed;
        orbiting = false;
    }
    // orbit
    orbit += orbit_speed;
    x = current_orb.x - cos(degtorad(orbit)) * current_orb.orbit_radius;
    y = current_orb.y + sin(degtorad(orbit)) * current_orb.orbit_radius;
    // set direction to orbit tangent
    direction = orbit - (sign(orbit_speed) * 90);
}
else {
    for (var i = 0; i &lt; instance_number(o_orb); i++) {
        var orb = instance_find(o_orb, i);
        // if the player will collide with the orbit in the next step
        if (point_in_circle(x + hspeed, y + vspeed, orb.x, orb.y, orb.orbit_radius)) {
            //if the collision will be with a void orb, die
            if (orb.orb_type == VOID_ORB) {
                instance_destroy();
                break;
            }
            
            // if the collision will be with an opponent-captured orb OR a dead orb 
            if ((orb.orb_type == DEFAULT_ORB &amp;&amp; orb.capturer != -1 &amp;&amp; orb.capturer != id)
                || orb.orb_type == DEAD_ORB) {
                ricochet_off_orb(orb, false);
                break;
            }
            
            // translate onto orbit
            orbit = point_direction(x, y, orb.x, orb.y);
            x = orb.x - cos(degtorad(orbit)) * orb.orbit_radius;
            y = orb.y + sin(degtorad(orbit)) * orb.orbit_radius;
            // set clockwise or counter-clockwise orbit depending on collision angle
            orbit_speed = sign(angle_difference(orbit, direction)) * orbit_speed_set;
            if (orbit_speed == 0) {
                orbit_speed = choose(orbit_speed_set, -orbit_speed_set);
            }
            // set orb capture status if not yet captured
            if (!orb.captured) {
                orb.captured = true;
                orb.capturer = self.id;
                orb.color = self.color;
                num_orb_captured++;
            }
            speed = 0;
            orbiting = true;
            current_orb = orb;
            
            //you won
            if (orb.orb_type == MASTER_ORB) {
                num_orb_captured = instance_number(o_orb);
            }
        }
    }
    // Reset orb speed
    if (current_orb != -1) {
        current_orb.speed = lerp(current_orb.speed,current_orb.initial_speed,0.1);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_circle_precision(64);
draw_set_colour(color);
draw_trail(trail_length, radius * 2, color, -1, true, 1);
draw_circle(x, y, radius, false);

if (global.tmp_visuals_on) {
    draw_text(x, y + 20, num_orb_captured);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
