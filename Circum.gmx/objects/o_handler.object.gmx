<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-999</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Pre-Spawn Initialization

window_set_cursor(cr_none);  // not changed in global game settings because of debug room

// init global vars
instance_create(0, 0, o_globals);

p_emitter = part_emitter_create(global.p_system);
p_type = part_type_create();

// Screen (Circular)
screen = surface_create(room_width, room_height);
drawn_to_surface = false;

tut_count = -1;
if (room_get_name(room) == "rm_tutorial"){
    tut_count = 0;
    alpha_transition = 0;
    prev_player_color = -1;
    tutorial_text = "Tap to launch#Hold to tether";
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player and Orb Spawns
randomize();

level_create();

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Defunct Player and Orb Spawns
/*
randomize();

//available for capture
num_free = 5;
//already claimed (not counting the orb you start on)
num_owned = 1;
//claimed by opponent (must be liberated by hammer)
num_opponent = 3;
//ricochet
num_dead = 3;
//dangerous
num_void = 1;

//how many orbs circle the starting orb
num_orb = num_free + num_owned + num_opponent + num_dead + num_void;

//the orb you start on plus all the DEFAULT orbs
num_to_win = 1+num_free + num_owned + num_opponent;

edge_buffer = 512;

var x_center = SCREEN_RADIUS;
var y_center = SCREEN_RADIUS;

// Screen (Circular)
screen = surface_create(room_width, room_height);

//starting orb
var orb;
orb = instance_create(x_center, y_center, o_orb);
//orb.speed = 0;
orb.fixed = true;
// Player
player_color = c_fuchsia;
player_id = -1;
with (instance_create(orb.x, y_center, o_player)) {
    num_orb_captured = other.num_owned;
    color = other.player_color;
    action_key = vk_space;
    num_to_win = other.num_to_win;
    other.player_id = self.id;
}

// hidden opponent
opponent_color = c_aqua;
opponent_id = -1;
with (instance_create(0,0, o_player)) {
    action_key = vk_escape;
    num_to_win = other.num_orb+1;
    visible = false;
    speed = 0;
    launch_speed = 0;
    orbit_speed = 0;
    other.opponent_id = self.id;
}

// Orbs that circle the starting orb
var rad = room_width/3;
for (var dir = 0; dir &lt; 360; dir += 360/num_orb) {
    var orb_x = x_center + rad*cos(degtorad(dir));
    var orb_y = y_center - rad*sin(degtorad(dir));
    with (instance_create(orb_x, orb_y, o_orb)) {
        speed = random_range(3,7);
        direction = random(360);
    }
}

//set their capturer or type
var orb_categories;
orb_categories[0] = num_free;
orb_categories[1] = num_owned;
orb_categories[2] = num_opponent;
orb_categories[3] = num_dead;
orb_categories[4] = num_void;

//loop thru orbs that circle the starting orb
var o_index = 1;
for(var i = 0; i &lt; 5; i++){
    for(var j = 0; j &lt; orb_categories[i]; j++){
        var cur_orb = instance_find(o_orb,o_index);
        
        //set parameters based on category
        switch(i){
        //free
        case 0: break;
        //already captured
        case 1:
            with cur_orb {
                captured = true;
                capturer = other.player_id;
                color = other.player_color;
            }
            break;
        //opponent captured
        case 2:
            with cur_orb {
                captured = true;
                capturer = other.opponent_id;
                color = other.opponent_color;
            }
            break;
        case 3:
            set_orb_type(cur_orb,DEAD_ORB);
            break;
        case 4:
            set_orb_type(cur_orb,VOID_ORB);
            break;
        }
        o_index++;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean up

part_emitter_destroy(global.p_system, p_emitter);
part_type_destroy(p_type);

surface_free(screen);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// End, Restart

if (keyboard_check_pressed(vk_escape)) {
    game_end();
}

if (keyboard_check_pressed(ord("R"))) {
    if (keyboard_check(vk_shift)) {
        game_restart();
    }
    else {
        // RESTART CURRENT LEVEL
        with (o_orb) {
            instance_destroy();
        }
        with (o_player) {
            instance_destroy();
        }
        if (room_get_name(room) == "rm_tutorial") {
            global.winner = -1;
            level_create();
        }
        else {
            // spawn orbs using global.orb_layout array
            for (var i = 0; i &lt; global.num_orb; i++) {
                var orb = instance_create(global.orb_layout[i, 0], global.orb_layout[i, 1], o_orb);
                set_orb_type(orb, global.orb_layout[i, 2]);
                if (global.orb_layout[i, 3]) {
                    orb.fixed = true;
                    orb.fixed_orbit = global.orb_layout[i, 4];
                    orb.fixed_orbit_speed = global.orb_layout[i, 5];
                    orb.fixed_orbit_radius = global.orb_layout[i, 6];
                }
            }
            /* The rest is copied from level_create() */
            // Spawn Starting Orb
            var start_orb = instance_create(SCREEN_RADIUS, SCREEN_RADIUS, o_orb);
            start_orb.speed = 0;  // not necessary if fixed = true, but let's keep it anyway
            start_orb.fixed = true;
            
            // Get number of orbs required to win (now that all orbs have been spawned)
            num_to_win = 0;
            with (o_orb) {
                if (type == DEFAULT_ORB) { other.num_to_win++; }
            }
            
            // Spawn Player
            plr_color = choose(c_fuchsia, c_aqua, c_lime, c_yellow);
            with (instance_create(SCREEN_RADIUS, SCREEN_RADIUS, o_player)) {
                color = other.plr_color;
                action_key = vk_space;
                num_to_win =  other.num_to_win; 
            }
            // set captured orbs' colors based on player color
            with (o_orb) {
                if (captured) {
                    do {
                        color = choose(c_fuchsia, c_aqua, c_lime, c_yellow);
                    } until (color != other.plr_color);
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Visual and Player Trail toggles

if (keyboard_check_pressed(ord("V"))) {
    global.tmp_visuals_on = !global.tmp_visuals_on;
}

if (keyboard_check_pressed(ord("T"))) {
    global.pre_fix_trail = !global.pre_fix_trail;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Return room_speed to normal

if (room_speed &lt; 60) {
    room_speed++;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Ambient Background Particles

background_particles();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Win tutorial stage

if (room_get_name(room) == "rm_tutorial" &amp;&amp; instance_exists(o_player)) {

    var plr = instance_find(o_player,0);
    if (plr.draw_radius &gt;= 2*SCREEN_RADIUS) {
    
        prev_player_color = plr.color;
        alpha_transition = 1;
            
        with (plr) { instance_destroy(); }
        global.winner = -1;
        
        with (o_orb) { instance_destroy(); }
        with (o_fake_player) { instance_destroy(); }
        
        tut_count = (tut_count + 1) % 6;
        level_create();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Framerate

debug_text = ("Framerate: " + string(fps) + "#");
debug_text += ("Actual Framerate: " + string(fps_real));
draw_set_alpha(1);
draw_set_color(c_white);
draw_text(0, 0, debug_text);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Circlular Screen

if (!drawn_to_surface) {  // this only needs to happen once
    drawn_to_surface = true;
    surface_set_target(screen);
    draw_clear_alpha(c_black, 1);  // make entire screen black
    draw_set_blend_mode(bm_subtract);
    // DRAW WITH PRIMITIVES OR VERTEX BUFFERS FOR GREATER PRECISION?!
    draw_set_circle_precision(64);
    draw_circle(room_width/2, room_height/2, room_width/2, false);
    draw_set_alpha(1);
    draw_set_blend_mode(bm_normal);
    surface_reset_target();
}

if (surface_exists(screen)) {
    draw_surface(screen, 0, 0);
}
else {
    screen = surface_create(room_width, room_height);
}

/// Tutorial text
if (tut_count &gt; -1 &amp;&amp; (!tutorial_text_appeared || tutorial_text_alpha &gt; 0.001)) {
    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_set_alpha(tutorial_text_alpha);
    draw_text_transformed(SCREEN_RADIUS,SCREEN_RADIUS-128,tutorial_text,2.5,2.5,0);
    if (!tutorial_text_appeared) {
        tutorial_text_alpha = lerp(tutorial_text_alpha,1,0.02);
        if (tutorial_text_alpha &gt;= 0.9) { tutorial_text_appeared = true; }
    }
    else { tutorial_text_alpha = lerp(tutorial_text_alpha,0,0.08); }
}

//fade-in
if (alpha_transition &gt; 0.001) {
    draw_set_alpha(alpha_transition);
    alpha_transition = lerp(alpha_transition,0,0.1);
    draw_set_color(prev_player_color);
    draw_circle(SCREEN_RADIUS,SCREEN_RADIUS,SCREEN_RADIUS,false);
    draw_set_alpha(1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
